var webgl, gui;

$(document).ready(init);

function init(){
    webgl = new Webgl(window.innerWidth, window.innerHeight);
    $('.three').append(webgl.renderer.domElement);

    gui = new dat.GUI();
    gui.add(webgl.camera.rotation, 'x').min(-20).max(20);
    gui.close();

    $(window).on('resize', resizeHandler);
    // when the mouse moves, call the given function
    $(window).on('mousemove', onDocumentMouseMove);

    animate();

}

function resizeHandler() {
    webgl.resize(window.innerWidth, window.innerHeight);
}

function onDocumentMouseMove(event) {
    // the following line would stop any other event handler from firing
    // (such as the mouse's TrackballControls)
    event.preventDefault();
    
    // update the mouse variable
    webgl.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    webgl.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
}

function animate() {
    requestAnimationFrame(animate);
    webgl.render();
}
var Webgl = (function(){

    function Webgl(width, height){
        webgl = this;

        // Basic three.js setup
        this.scene = new THREE.Scene();
        
        this.camera = new THREE.PerspectiveCamera(50, width / height, 1, 10000);
        this.camera.position.z = 300;

        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0x19bec0);

        this.composer = new THREE.EffectComposer(this.renderer);
        this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));

        // Glitch Effect
        glitchPass = new THREE.GlitchPass();
        glitchPass.renderToScreen = true;
        this.composer.addPass(glitchPass);
        this.glichEffect = false;

        // Lights
        this.light = new THREE.PointLight(0xffffff, 100, 1200);
        this.light.position.set(0, 0, 350);
        this.scene.add(this.light);

        this.ambientLight = new THREE.AmbientLight(0x666666);
        this.scene.add(this.ambientLight);

        // Global variables
        this.mouse = { x: 0, y: 0 };
        this.INTERSECTED;

        this.counter = 200;
        this.hoverInteraction = false;
        this.spreadParticles = false;

        // Cube Manager
        this.cubeManager = new CubeManager();
        // Display first cube
        this.cubeManager.animateFirstSquare();
        

        $(document).on('click', 'a.next', function(e) {
            e.preventDefault();
            $(this).fadeOut();
            $('h1.first').fadeOut();
            $('h1.second').fadeIn('slow');
            window.setTimeout(function() {
                $('h1.second').fadeOut('slow', function() {
                    $('h1.third').fadeIn();
                    webgl.cubeManager.addZCubes();
                    window.setTimeout(function() {
                        $('h1.third').fadeOut('slow');
                    }, 3000);
                });   
            }, 1000);         
        });

        //Haut, haut, bas, bas, gauche, droite, gauche, droite, B, A  
        /*var k = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65],  
        n = 0;  
        $(document).keydown(function (e) {  
            if (e.keyCode === k[n++]) {  
                if (n === k.length) {  
                    alert('Konami !!!'); // Ã  remplacer par votre code  
                    return !1  
                }  
            } else k = 0  
        }); */
    }

    Webgl.prototype.awayCamera = function() {
        TweenLite.to(webgl.camera.position, 0.8, {z: 1000, ease: Expo.easeOut, onComplete: function() {
            webgl.cubeManager.displayHorizontalCubes();
            webgl.cubeManager.popCubes(3, 8);
            webgl.cubeManager.popCubes(9, 14);
            webgl.cubeManager.displayVerticalCubes();
            webgl.hoverInteraction = true;
            window.setTimeout(function() {
                $('div.title').fadeIn('slow');
            }, 2000);
            
        }});
    };

    Webgl.prototype.moveLight = function() {
        TweenLite.to(this.light.position, 1, {x: 0, y: -100, z: 50});
        this.light.intensity = 200;
    }

    Webgl.prototype.resize = function(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    };

    Webgl.prototype.render = function() {    
        this.renderer.render(this.scene, this.camera);

        if (this.spreadParticles) {
            this.cubeParticles.update();
        }

        if (this.glichEffect) {
            this.composer.render();
        }

        if (this.hoverInteraction) {
            this.cubesHoverEffects();
        }
        if (this.cubeManager.cubesRotation) {
            this.cubeManager.rotateCubes();
        }
    };

    Webgl.prototype.cubesHoverEffects = function() {
        // find intersections

        // create a Ray with origin at the mouse position
        //   and direction into the scene (camera direction)
        var vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 1).unproject(this.camera);
        var ray = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());

        // create an array containing all objects in the scene with which the ray intersects
        var intersects = ray.intersectObjects(this.scene.children, true);
        
        // if there is one (or more) intersections
        if (intersects.length > 0)
        {
            // if the closest object intersected is not the currently stored intersection object
            if (intersects[0].object != this.INTERSECTED) 
            {
                if (this.INTERSECTED) {
                    TweenLite.to(this.INTERSECTED.scale, 0.1, {x: 1, y: 1});
                    TweenLite.to(this.INTERSECTED.rotation, 0.1, {z: 0});
                }
                // store reference to closest object as current intersection object
                this.INTERSECTED = intersects[0].object;
                TweenLite.to(this.INTERSECTED.scale, 0.1, {x: 1.4, y: 1.4});
                TweenLite.to(this.INTERSECTED.rotation, 0.1, {z: 10});
            }
        } 
        else // there are no intersections
        {
            if (this.INTERSECTED) {
                TweenLite.to(this.INTERSECTED.scale, 0.3, {x: 1, y: 1});
                TweenLite.to(this.INTERSECTED.rotation, 0.1, {z: 0});
            }

            this.INTERSECTED = null;
        }

        if (webgl.endingInteraction && this.INTERSECTED) {
            TweenLite.to(this.INTERSECTED.scale, 0.3, {x: 1, y: 1});
            TweenLite.to(this.INTERSECTED.rotation, 0.1, {z: 0});

            webgl.hoverInteraction = false;
        }
    }

    return Webgl;

})();
var Cube = (function(){

    function Cube(width, height, depth){
        THREE.Object3D.call(this);

        var geometry = new THREE.BoxGeometry(width, height, depth);
        var material = new THREE.MeshLambertMaterial({ color: 0xffffff})

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(0, 0, 0);
        //this.mesh.rotation.x = 10;
        this.add(this.mesh);
    }

    Cube.prototype = new THREE.Object3D;
    Cube.prototype.constructor = Cube;

    Cube.prototype.update = function() {
        //this.mesh.rotation.z += 0.01;
    };

    return Cube;
})();
var CubeManager = (function(){

	function CubeManager(){
		this.cubesDim = 100;
        this.cubesRotation = false;
		this.cubes = [];
	}

    CubeManager.prototype.constructor = CubeManager;

    CubeManager.prototype.animateFirstSquare = function() {
        cubeManager = this;
        var cube = new Cube(1, 1, 1);
        cube.scale.y = 10;
        cube.position.set(-this.cubesDim/2, -this.cubesDim/2 , 0);
        webgl.scene.add(cube);
        this.cubes = [cube];

        TweenLite.to(cube.scale, 0.8, {x: this.cubesDim, ease: Expo.easeIn});

        TweenLite.to(cube.position, 0.8, {x: 0, ease: Expo.easeIn});

        TweenLite.to(cube.scale, 0.8, {y: this.cubesDim, delay: 0.8, ease: Expo.easeOut});

        TweenLite.to(cube.position, 0.8, {y: 0, delay: 0.8, ease: Expo.easeOut, onComplete: function() {
            cubeManager.animateTwoSquares();
        }});
    };

    CubeManager.prototype.animateTwoSquares = function() {
        this.cubes.push(new Cube(1, 1, 1), new Cube(1, 1, 1));
        this.cubes[1].scale.x = this.cubesDim;
        this.cubes[1].scale.y = this.cubesDim;
        this.cubes[2].scale.x = this.cubesDim;
        this.cubes[2].scale.y = this.cubesDim;

        webgl.scene.add(this.cubes[1]);
        webgl.scene.add(this.cubes[2]);

        TweenLite.to(this.cubes[1].position, 0.8, {x: -150, ease: Expo.easeOut});

        TweenLite.to(this.cubes[2].position, 0.8, {x: 150, ease: Expo.easeOut, onComplete: function() {
            webgl.awayCamera();  
        }});
    };

    CubeManager.prototype.displayHorizontalCubes = function() {
        // Left
        for (var i = -2; i >= -7; i--) {
            var cube = new Cube(1, 1, 1);
            cube.position.set(i* 150 ,0, 0);
            this.cubes.push(cube);
        }
        // Right
        for (var i = 2; i <= 7; i++) {
            var cube = new Cube(1, 1, 1);
            cube.position.set(i* 150 ,0, 0);
            this.cubes.push(cube);
        }
    };

    CubeManager.prototype.popCubes = function(minIndex, maxIndex) {
        var j = 0;
        for (var i = minIndex; i <= maxIndex; i++) {
            var cube = this.cubes[i];
            webgl.scene.add(cube);
            TweenLite.to(cube.scale, 0.3, {x: this.cubesDim, y: this.cubesDim, z: 1, ease: Expo.easeOut, delay: j*0.1, onStart:function() {
                document.getElementById('pop').play();
            }});
            j++;
        }
    };

    CubeManager.prototype.displayVerticalCubes = function() {
        for (var j = -7; j <= 7; j++) {
            for (var i = 1; i <= 3; i++) {
                var cube = new Cube(1, 1, 1);
                cube.position.set(j*150, i*150, 0);
                cube.scale.x = 0.1;
                cube.scale.y = 0.1;
                this.cubes.push(cube);
                webgl.scene.add(cube);
                TweenLite.to(cube.scale, 0.3, {x: this.cubesDim, y: this.cubesDim, z: 1, ease: Expo.easeOut, delay: (j*0.1)+1, onStart: function() {
                    document.getElementById('pop').play();
                }});
            }
            for (var i = -1; i >= -3; i--) {
                var cube = new Cube(1, 1, 1);
                cube.position.set(j*150, i*150, 0);
                cube.scale.x = 0.1;
                cube.scale.y = 0.1;
                this.cubes.push(cube);
                webgl.scene.add(cube);
                TweenLite.to(cube.scale, 0.3, {x: this.cubesDim, y: this.cubesDim, z: 1, ease: Expo.easeOut, delay: (j*0.1)+1, onStart: function() {
                    document.getElementById('pop').play();
                }});
            }
        }
        
    };

    CubeManager.prototype.addZCubes = function() {
        cubeManager = this;
        var i = 0;
        for (i = 0; i < this.cubes.length; i++) {
            TweenLite.to(this.cubes[i].scale, 1, {x: 100, y: 100, z: 100, delay: 0.4, ease: Expo.easeOut, onStart: function() {
                webgl.endingInteraction = true;
            },
            onComplete: function() {
                window.setTimeout(function() {
                    cubeManager.cubesRotation = true;
                    document.getElementById('c2c').play();
                    webgl.moveLight();
                }, 500);
            }});
        }
    };

    CubeManager.prototype.rotateCubes = function() {
        if (webgl.counter % 200 == 0) {
            this.rotationSpeed = webgl.counter / 200 * 0.01;
        }
        var i = 0;
        for (i = 0; i < this.cubes.length; i++) {
            this.cubes[i].rotation.x += this.rotationSpeed;
        }

        if (webgl.counter == 1000) {
            this.moveCubesToCenter();
            webgl.counter = -1
        }
        
        if (webgl.counter >= 0) {
            webgl.counter += 1;
        }
    };

    CubeManager.prototype.moveCubesToCenter = function() {
        cubeManager = this;
        for (i = 0; i < this.cubes.length; i++) {
            TweenLite.to(this.cubes[i].position, 7, {x: 0, y: 0, z: 0, ease: Quad.easeIn, delay: i*0.03});
            TweenLite.to(this.cubes[i].rotation, 1, {z: -10, ease: Quad.easeIn, delay: i*0.03});
            TweenLite.to(this.cubes[i].rotation, 1, {z: 10, ease: Quad.easeIn, delay: i*0.03 + 4.15});
        }
        window.setTimeout(function() {
            cubeManager.removeAllCubesButFirst();
            TweenLite.to(cubeManager.cubes[0].rotation, 1, {z: 0, ease: Quad.easeIn});
        }, 10150);
    };

    CubeManager.prototype.removeAllCubesButFirst = function() {
        for (i = 1; i < this.cubes.length; i++) {
            webgl.scene.remove(this.cubes[i]);
        }
        var firstCube = this.cubes[0];
        this.cubes = [firstCube];
        this.growCube();
    };

    CubeManager.prototype.growCube = function() {
        cubeManager = this;
        TweenLite.to(this.cubes[0].scale, 0.8, {x: 300, y: 300, z: 300, ease: Expo.easeIn, onComplete: function() {
            cubeManager.cubesRotation = false;
            TweenLite.to(cubeManager.cubes[0].rotation, 1.2, {x: 0, onComplete: function() {
                window.setTimeout(function() {
                    webgl.scene.remove(cubeManager.cubes[0]);

                    webgl.cubeParticles = new CubeParticles();
                    webgl.spreadParticles = true;
                    webgl.scene.add(webgl.cubeParticles);
                    webgl.cubeParticles.explode();
                }, 1000);

                window.setTimeout(function() {
                    webgl.glichEffect = true;
                }, 4000);
            }});
        }});
    }

    return CubeManager;

})();
var CubeParticles = (function(){

    function CubeParticles() {
        THREE.Object3D.call(this);
        
        this.particles = 8000;
        this.rotate = false;
        this.colors = [new THREE.Color(0x113F59), new THREE.Color(0x19BEC0), new THREE.Color(0xF3EDD3), new THREE.Color(0xD54F58), new THREE.Color(0x444444)];

        var geometry = new THREE.BufferGeometry();

        var positions = new Float32Array( this.particles * 3 );
        var colors = new Float32Array( this.particles * 3 );

        var color = new THREE.Color();

        var n = 300, n2 = n / 2; // particles spread in the cube

        for ( var i = 0; i < positions.length; i += 3 ) {

            // positions

            var x = Math.random() * n - n2;
            var y = Math.random() * n - n2;
            var z = Math.random() * n - n2;

            positions[ i ]     = x;
            positions[ i + 1 ] = y;
            positions[ i + 2 ] = z;

            // colors

            colors[ i ]     = 102 / 255;
            colors[ i + 1 ] = 102 / 255;
            colors[ i + 2 ] = 102 / 255;

        }

        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

        geometry.computeBoundingSphere();

        //

        var material = new THREE.PointCloudMaterial( { size: 10, vertexColors: THREE.VertexColors } );

        this.particleSystem = new THREE.PointCloud( geometry, material );
        this.add(this.particleSystem);
    }

    CubeParticles.prototype = new THREE.Object3D;
    CubeParticles.prototype.constructor = CubeParticles;

    CubeParticles.prototype.explode = function() {
        var cubeParticles = this;

        var positions = this.particleSystem.geometry.attributes.position.array;

        var n = window.innerWidth, n2 = n / 2;

        var newPositions = new Float32Array( this.particles * 3 );
        for(var i = 0; i < newPositions.length; i += 3) {
            var x = Math.random() * n - n2;
            var y = Math.random() * n - n2;
            var z = Math.random() * n - n2;

            newPositions[ i ]     = x;
            newPositions[ i + 1 ] = y;
            newPositions[ i + 2 ] = z;
        }
        
        newPositions.onComplete = function() {
            cubeParticles.rotate = true;
        };
        TweenLite.to(this.particleSystem.geometry.attributes.position.array, 5, newPositions);
        window.setInterval(function() {
            TweenLite.to(cubeParticles.rotation, 1, {y: 100, ease: Expo.easeOut});
            webgl.renderer.setClearColor(0xF3EDD3);
            window.setTimeout(function() {
                webgl.renderer.setClearColor(0x19bec0);
            }, 1500);
        }, 12000);
    }

    CubeParticles.prototype.changeColors = function() {
        var colors = this.particleSystem.geometry.attributes.color.array;

        var newColors = new Float32Array( this.particles * 3 );
        for(var i = 0; i < newColors.length; i += 3) {
            var newColor = this.colors[Math.floor(Math.random() * this.colors.length)];

            newColors[ i ]     = newColor.r;
            newColors[ i + 1 ] = newColor.g;
            newColors[ i + 2 ] = newColor.b;
        }

        this.particleSystem.geometry.attributes.color.array = newColors;
    }

    CubeParticles.prototype.update = function() {
        this.particleSystem.geometry.attributes.position.needsUpdate = true;
        this.particleSystem.geometry.attributes.color.needsUpdate = true;

        this.changeColors();

        if (this.rotate) {
            this.rotation.y += 0.005;
        }
    }

    return CubeParticles;

})();

var Sphere = (function(){

    function Sphere(){
        THREE.Object3D.call(this);

        var geometry = new THREE.SphereGeometry(35);
        var material = new THREE.MeshBasicMaterial({color: 0x3facc8, wireframe: true});
        this.mesh = new THREE.Mesh(geometry, material);
        this.add(this.mesh);
    }

    Sphere.prototype = new THREE.Object3D;
    Sphere.prototype.constructor = Sphere;

    Sphere.prototype.update = function() {
        this.mesh.rotation.y += 0.01;
    };

    return Sphere;
})();
var Triangle = (function(){

    function Triangle(){
        THREE.Object3D.call(this);

        var geometry = new THREE.TetrahedronGeometry(70, 0);

        //geometry.faces[0].color.setHex(0x888888);

        for ( var i = 0; i < geometry.faces.length; i ++ ) {
            geometry.faces[ i ].color.setHex( Math.random() * 0xffffff );
        }

        var material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            vertexColors: THREE.FaceColors
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.y = Math.PI/4;
        this.mesh.rotation.x = Math.PI;
        this.add(this.mesh);
    }

    Triangle.prototype = new THREE.Object3D;
    Triangle.prototype.constructor = Triangle;

    Triangle.prototype.update = function() {
        //this.mesh.rotation.x += 0.01;
    };

    return Triangle;
})();
//# sourceMappingURL=app.min.js.map