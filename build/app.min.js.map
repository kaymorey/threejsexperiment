{"version":3,"sources":["main.js","webgl.js","objects/Cube.js","objects/Sphere.js","objects/Triangle.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.min.js","sourcesContent":["var webgl, gui;\n\n$(document).ready(init);\n\nfunction init(){\n    webgl = new Webgl(window.innerWidth, window.innerHeight);\n    $('.three').append(webgl.renderer.domElement);\n\n    gui = new dat.GUI();\n    //gui.add(webgl.triangle.rotation, 'x').min(-Math.PI).max(Math.PI);\n    gui.close();\n\n    $(window).on('resize', resizeHandler);\n    // when the mouse moves, call the given function\n    $(window).on('mousemove', onDocumentMouseMove);\n\n    animate();\n}\n\nfunction resizeHandler() {\n    webgl.resize(window.innerWidth, window.innerHeight);\n}\n\nfunction onDocumentMouseMove(event) {\n    // the following line would stop any other event handler from firing\n    // (such as the mouse's TrackballControls)\n    // event.preventDefault();\n    \n    // update the mouse variable\n    webgl.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n    webgl.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n}\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    webgl.render();\n    webgl.update();\n}","var Webgl = (function(){\n\n    function Webgl(width, height){\n        webgl = this;\n        // Basic three.js setup\n        this.scene = new THREE.Scene();\n        \n        this.camera = new THREE.PerspectiveCamera(50, width / height, 1, 10000);\n        this.camera.position.z = 300;\n\n        this.renderer = new THREE.WebGLRenderer();\n        this.renderer.setSize(width, height);\n        this.renderer.setClearColor(0xebc130);\n\n        this.cubesDim = 100;\n\n        this.cube = new Cube(1, 10, 0);\n        this.cube.position.set(-this.cubesDim/2, -this.cubesDim/2 , 0);\n        this.scene.add(this.cube);\n\n        var scaleXCube = new TimelineLite();\n        scaleXCube.to(this.cube.scale, 0.8, {x: this.cubesDim, ease: Expo.easeIn});\n\n        var positionXCube = new TimelineLite();\n        positionXCube.to(this.cube.position, 0.8, {x: 0, ease: Expo.easeIn});\n\n        var scaleYCube = new TimelineLite();\n        scaleYCube.to(this.cube.scale, 0.8, {y: this.cubesDim/10, delay: 0.8, ease: Expo.easeOut});\n\n        var positionYCube = new TimelineLite();\n        positionYCube.to(this.cube.position, 0.8, {y: 0, delay: 0.8, ease: Expo.easeOut, onComplete: function() {\n            animateTwoSquares();\n        }});\n\n        this.genericCube = new Cube(1, 1, 0);\n        this.genericCube.position.set(0, 0, 0);\n\n        this.flatCube = this.genericCube.clone();\n        this.flatCube.scale.x = this.cubesDim;\n        this.flatCube.scale.y = this.cubesDim;\n\n        this.cubes = [this.flatCube.clone(), this.flatCube.clone()];\n\n        var animateTwoSquares = function() {\n            webgl.scene.add(webgl.cubes[0]);\n            webgl.scene.add(webgl.cubes[1]);\n\n            var positionCube0 = new TimelineLite();\n            positionCube0.to(webgl.cubes[0].position, 0.8, {x: -150, ease: Expo.easeOut});\n\n            var positionCube1 = new TimelineLite();\n            positionCube1.to(webgl.cubes[1].position, 0.8, {x: 150, ease: Expo.easeOut, onComplete: function() {\n                awayCamera();  \n            }});\n        }\n\n        var awayCamera = function() {\n            var cameraPosition = new TimelineLite();\n            cameraPosition.to(webgl.camera.position, 0.8, {z: 1000, ease: Expo.easeOut, onComplete: function() {\n                displayHorizontalCubes();\n                popCubes(2, 7);\n                popCubes(8, 13);\n                displayVerticalCubes();\n            }});\n        }\n\n        function popCubes(minIndex, maxIndex) {\n            var j = 0;\n            for (var i = minIndex; i <= maxIndex; i++) {\n                var cube = webgl.cubes[i];\n                webgl.scene.add(cube);\n                var scaleCube = new TimelineLite();\n                scaleCube.to(cube.scale, 0.3, {x: webgl.cubesDim, y: webgl.cubesDim, z: 1, ease: Expo.easeOut, delay: j*0.1});\n                j++;\n            }\n        }\n\n        function displayHorizontalCubes() {\n            // Left\n            for (var i = -2; i >= -7; i--) {\n                var cube = webgl.genericCube.clone();\n                cube.position.set(i* 150 ,0, 0);\n                webgl.cubes.push(cube);\n            }\n            // Right\n            for (var i = 2; i <= 7; i++) {\n                var cube = webgl.genericCube.clone();\n                cube.position.set(i* 150 ,0, 0);\n                webgl.cubes.push(cube);\n            }\n        }\n\n        function displayVerticalCubes() {\n            for (var j = -7; j <= 7; j++) {\n                for (var i = 1; i <= 3; i++) {\n                    var cube = webgl.genericCube.clone();\n                    cube.position.set(j*150, i*150, 0);\n                    cube.scale.x = 0.1;\n                    cube.scale.y = 0.1;\n                    webgl.cubes.push(cube);\n                    webgl.scene.add(cube);\n                    var scaleCube = new TimelineLite();\n                    scaleCube.to(cube.scale, 0.3, {x: webgl.cubesDim, y: webgl.cubesDim, z: 1, ease: Expo.easeOut, delay: (j*0.1)+1});\n                }\n                for (var i = -1; i >= -3; i--) {\n                    var cube = webgl.genericCube.clone();\n                    cube.position.set(j*150, i*150, 0);\n                    cube.scale.x = 0.1;\n                    cube.scale.y = 0.1;\n                    webgl.cubes.push(cube);\n                    webgl.scene.add(cube);\n                    var scaleCube = new TimelineLite();\n                    scaleCube.to(cube.scale, 0.3, {x: webgl.cubesDim, y: webgl.cubesDim, z: 1, ease: Expo.easeOut, delay: (j*0.1)+1});\n                }\n            }\n            \n        }\n\n    }\n\n    Webgl.prototype.resize = function(width, height) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(width, height);\n    };\n\n    Webgl.prototype.render = function() {    \n        this.renderer.render(this.scene, this.camera);\n\n        // this.someObject.rotation.y += 0.01;\n        // this.someObject.rotation.x += 0.01;\n\n        //this.triangle.update();\n    };\n\n    Webgl.prototype.update = function() {\n        // find intersections\n\n    // create a Ray with origin at the mouse position\n    //   and direction into the scene (camera direction)\n    var vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 1);\n    projector.unprojectVector( vector, camera );\n    var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );\n\n    // create an array containing all objects in the scene with which the ray intersects\n    var intersects = ray.intersectObjects( scene.children );\n    \n    // if there is one (or more) intersections\n    if ( intersects.length > 0 )\n    {\n        // if the closest object intersected is not the currently stored intersection object\n        if ( intersects[ 0 ].object != INTERSECTED ) \n        {\n            // restore previous intersection object (if it exists) to its original color\n            if ( INTERSECTED ) \n                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n            // store reference to closest object as current intersection object\n            INTERSECTED = intersects[ 0 ].object;\n            // store color of closest object (for later restoration)\n            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n            // set a new color for closest object\n            INTERSECTED.material.color.setHex( 0xffff00 );\n        }\n    } \n    else // there are no intersections\n    {\n        // restore previous intersection object (if it exists) to its original color\n        if ( INTERSECTED ) \n            INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n        // remove previous intersection object reference\n        //     by setting current intersection object to \"nothing\"\n        INTERSECTED = null;\n    }\n\n    return Webgl;\n\n})();","var Cube = (function(width, height, depth){\n\n    function Cube(width, height, depth){\n        THREE.Object3D.call(this);\n\n        var geometry = new THREE.BoxGeometry(width, height, depth);\n        var material = new THREE.MeshBasicMaterial({color: 0xFFFFFF});\n\n        this.mesh = new THREE.Mesh(geometry, material);\n        //this.mesh.rotation.x = 10;\n        this.add(this.mesh);\n    }\n\n    Cube.prototype = new THREE.Object3D;\n    Cube.prototype.constructor = Cube;\n\n    Cube.prototype.update = function() {\n        //this.mesh.rotation.z += 0.01;\n    };\n\n    return Cube;\n})();","var Sphere = (function(){\n\n    function Sphere(){\n        THREE.Object3D.call(this);\n\n        var geometry = new THREE.SphereGeometry(35);\n        var material = new THREE.MeshBasicMaterial({color: 0x3facc8, wireframe: true});\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.add(this.mesh);\n    }\n\n    Sphere.prototype = new THREE.Object3D;\n    Sphere.prototype.constructor = Sphere;\n\n    Sphere.prototype.update = function() {\n        this.mesh.rotation.y += 0.01;\n    };\n\n    return Sphere;\n})();","var Triangle = (function(){\n\n    function Triangle(){\n        THREE.Object3D.call(this);\n\n        var geometry = new THREE.TetrahedronGeometry(70, 0);\n\n        //geometry.faces[0].color.setHex(0x888888);\n\n        for ( var i = 0; i < geometry.faces.length; i ++ ) {\n            geometry.faces[ i ].color.setHex( Math.random() * 0xffffff );\n        }\n\n        var material = new THREE.MeshBasicMaterial({\n            color: 0xffffff,\n            vertexColors: THREE.FaceColors\n        });\n\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.mesh.rotation.y = Math.PI/4;\n        this.mesh.rotation.x = Math.PI;\n        this.add(this.mesh);\n    }\n\n    Triangle.prototype = new THREE.Object3D;\n    Triangle.prototype.constructor = Triangle;\n\n    Triangle.prototype.update = function() {\n        //this.mesh.rotation.x += 0.01;\n    };\n\n    return Triangle;\n})();"],"sourceRoot":"/source/"}